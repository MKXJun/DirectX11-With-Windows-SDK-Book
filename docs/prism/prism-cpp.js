(function (Prism) {

	var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|size_t|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while|__int(8|16|32|64)|__uuidof)\b/;
	var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function () { return keyword.source; });
	var stlClassName = /\b(?:w?string|vector|(unordered_)?(set|map))\b/
    var d3dClassName = /\b(?:IUnknown|ID3D11(Device(Context)?|Buffer|ClassInstance|Texture[1-3]D|Resource|(ShaderResource|RenderTarget|DepthStencil|UnorderedAccess)View|(Rasterizer|DepthStencil|Sampler|Blend)State|(Vertex|Hull|Domain|Geometry|Pixel|Compute)Shader|InputLayout)[1-9]?|IDXGI(SwapChain|Surface|Device|Factory|Adapter|Output)[1-9]?|ID3DBlob|(C|F|G|H)?XM(VECTOR(F32)?|MATRIX|(FLOAT|INT|UINT)[2-4](X[2-4])?)|D3D_(FEATURE_LEVEL|DRIVER_TYPE)|DXGI_(SWAP_EFFECT|FORMAT|MODE_DESC|MODE_SCANLINE_ORDER|MODE_SCALING|SCALING|ALPHA_MODE|USAGE|SWAP_CHAIN_DESC[1-9]?|SAMPLE_DESC|SWAP_CHAIN_FULLSCREEN_DESC|RATIONAL)|(C)?D3D11_(TEXTURE[1-3]D|BUFFER|(RENDER_TARGET|DEPTH_STENCIL|UNORDERED_ACCESS|SHADER_RESOURCE)_VIEW|INPUT_ELEMENT|RASTERIZER|SAMPLER|DEPTH_STENCIL|DEPTH_STENCILOP)_DESC|D3D11_(BLEND(_OP)?|STENCIL_OP|(COMPARISON)_FUNC|DEPTH_WRITE_MASK|(SRV|RTV|UAV|DSV)_DIMENSION|(BUFFER(EX)?|TEX([1-3]D(MS)?|CUBE)(_ARRAY)?)_(SRV|UAV|DSV|RTV)|FILTER|TEXTURE_ADDRESS_MODE|BOX|(FILL|CULL)_MODE|INPUT_CLASSIFICATION|MAP(PED_SUBRESOURCE)?|SUBRESOURCE_DATA|USAGE)|(C)?D3D11_VIEWPORT|DDS_ALPHA_MODE)\b/
	var winClassName = /\b(?:D3DApp|GameApp|U?INT(8)?|HWND|HINSTANCE|HRESULT|HMODULE|BOOL|BYTE|SIZE_T|FLOAT|WCHAR|LP(C)?STR|ComPtr)\b/
	Prism.languages.cpp = Prism.languages.extend('c', {
		'class-name': [
			{
				pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source
					.replace(/<keyword>/g, function () { return keyword.source; })),
				lookbehind: true
			},
			// This is intended to capture the class name of method implementations like:
			//   void foo::bar() const {}
			// However! The `foo` in the above example could also be a namespace, so we only capture the class name if
			// it starts with an uppercase letter. This approximation should give decent results.
			/\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
			// This will capture the class name before destructors like:
			//   Foo::~Foo() {}
			/\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
			// This also intends to capture the class name of method implementations but here the class has template
			// parameters, so it can't be a namespace (until C++ adds generic namespaces).
			/\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/,
			stlClassName,
			d3dClassName,
			winClassName
		],
		'keyword': keyword,
		'number': {
			pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
			greedy: true
		},
		'operator': />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
		'boolean': /\b(?:false|true)\b/
	});

	Prism.languages.insertBefore('cpp', 'string', {
		'module': {
			// https://en.cppreference.com/w/cpp/language/modules
			pattern: RegExp(
				/(\b(?:import|module)\s+)/.source +
				'(?:' +
				// header-name
				/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source +
				'|' +
				// module name or partition or both
				/<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +
				')'
			),
			lookbehind: true,
			greedy: true,
			inside: {
				'string': /^[<"][\s\S]+/,
				'operator': /:/,
				'punctuation': /\./
			}
		},
		'raw-string': {
			pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
			alias: 'string',
			greedy: true
		}
	});

	Prism.languages.insertBefore('cpp', 'keyword', {
		'generic-function': {
			pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
			inside: {
				'function': /^\w+/,
				'generic': {
					pattern: /<[\s\S]+/,
					alias: 'class-name',
					inside: Prism.languages.cpp
				}
			}
		}
	});

	Prism.languages.insertBefore('cpp', 'operator', {
		'double-colon': {
			pattern: /::/,
			alias: 'punctuation'
		}
	});

	Prism.languages.insertBefore('cpp', 'class-name', {
		// the base clause is an optional list of parent classes
		// https://en.cppreference.com/w/cpp/language/class
		'base-clause': {
			pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
			lookbehind: true,
			greedy: true,
			inside: Prism.languages.extend('cpp', {})
		}
	});

	Prism.languages.insertBefore('inside', 'double-colon', {
		// All untokenized words that are not namespaces should be class names
		'class-name': /\b[a-z_]\w*\b(?!\s*::)/i
	}, Prism.languages.cpp['base-clause']);

}(Prism));
